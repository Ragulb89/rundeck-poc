---
- hosts: all
  gather_facts: True
  #gather_facts: False
  vars_files:
   - vars/patch_variables.yml
  tasks:
   - name: get current time before reboot
     command: date +%s
     register: before_reboot
   
   - name: Maintanence mode science logic
     local_action: shell {{ scilo_maint_on }} {{ inventory_hostname }}
     register: scilo_on
     changed_when: "scilo_on.rc == 0"
     ignore_errors: true
     become: false

   - name: clean up {{ yum_cache }}
     shell: "rm -rf {{ yum_cache }}"
     become: true
   - name: set channel name
     set_fact: 
       channel: "rhel{{ ansible_distribution_major_version }}_{{ quarters[month].qyear }}_{{ quarters[month].qmonth }}"

   - name: register to channel using activationkey
     command: rhnreg_ks --force --username={{ sat_user }} --password={{ sat_pass }} --activationkey 1-{{ channel }}
     register: rhnreg_result
     changed_when: "rhnreg_result.rc == 0"
     environment:
       PATH: "{{ ansible_env.PATH }}:/sbin:/usr/sbin"
     become: true


   - name: reboot server
     command: "shutdown -r 0"
     async: 0
     poll: 0
     ignore_errors: true
     become: true
     environment:
       PATH: "{{ ansible_env.PATH }}:/sbin:/usr/sbin"

   - name: wait for server to come back
     # local_action is not the preferred way, use 'delegate_to: localhost' instead
     local_action: wait_for host={{ ansible_host | default(inventory_hostname,boolean=True) }}
       port=22 
       delay=130
       state=started 
     become: false
     register: waitfor
     ignore_errors: true
     # you should not use ignore_errors unless you really need to because something is broken.

   - name: verify a reboot actually occured
     shell: "[ $(( $(date +%s) - $(awk -F . '{print $1}' /proc/uptime) )) -gt {{ before_reboot.stdout }} ] || echo FAILED"
     register: reboot_chk
     failed_when: "'FAILED' in reboot_chk.stdout"
     when: waitfor|succeeded

   - name: yum update
     yum:
       name: '*'
       state: latest
     register: yum_update
     ignore_errors: yes
     become: true

   - name: save yum update in {{yum_update_log}}
     copy:
       content: "{{ yum_update | replace('\\n','\n') }}"
       dest: "{{ yum_update_log }}"
       owner: root
       group: unixeng
       mode: 0664
     become: true

   - name: email yum log on fail
     local_action: shell echo "Rundeck - yum update failed, to troubleshoot look at {{ yum_update_log }}" | mailx -s "FAILED Patch on {{ inventory_hostname }} - yum update failed" -S from= "{{ from_email }}" "{{ to_email }}"
     register: mailx
     failed_when: mailx.rc == 0
     when: yum_update|failed
     environment:
       PATH: "{{ ansible_env.PATH }}:/sbin:/usr/sbin:/usr/bin"
     become: false

   - name: email yum message when no update
     local_action: shell echo -e "Rundeck - yum update:\n{{ yum_update.results | replace('\\n','\n') }}" | mailx -s "UNNEEDED Patch on {{ inventory_hostname }} - no packages to update" -S from= "{{ from_email }}" "{{ to_email }}"
     register: mailx
     when: not yum_update|changed
     environment:
       PATH: "{{ ansible_env.PATH }}:/sbin:/usr/sbin:/usr/bin"
     become: false
 
   - name: reboot after patching
     command: "shutdown -r 0"
     async: 0
     poll: 0
     ignore_errors: true
     become: true
     when: yum_update|succeeded
     environment:
       PATH: "{{ ansible_env.PATH }}:/sbin:/usr/sbin"
   - name: wait for server to come back after yum update
     local_action: wait_for host={{ ansible_host | default(inventory_hostname,boolean=True) }}
       port=22
       delay=130
       state=started
     become: false
     register: waitfor
     ignore_errors: true

  
   - name: Maintanence mode science logic turn off
     local_action: shell {{ scilo_maint_off }} {{ inventory_hostname }}
     register: scilo_off
     changed_when: "scilo_off.rc == 0"
     ignore_errors: true
     become: false
